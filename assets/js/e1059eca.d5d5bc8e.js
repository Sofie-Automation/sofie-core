"use strict";(self.webpackChunksofie_documentation=self.webpackChunksofie_documentation||[]).push([[942],{71926:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"for-developers/device-integrations/tsr-actions","title":"TSR Actions","description":"Sometimes a state based model isn\'t enough and you just need to fire an action. In Sofie we try to be strict about any playout operations needing to be state based, i.e. doing a transition operation on a vision mixer should be a result of a state change, not an action. However, there are things that are easier done with actions. For example cleaning up a playlist on a graphics server or formatting a disk on a recorder. For these scenarios we have added TSR Actions.","source":"@site/docs/for-developers/device-integrations/tsr-actions.md","sourceDirName":"for-developers/device-integrations","slug":"/for-developers/device-integrations/tsr-actions","permalink":"/sofie-core/docs/for-developers/device-integrations/tsr-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/Sofie-Automation/sofie-core/edit/main/packages/documentation/docs/for-developers/device-integrations/tsr-actions.md","tags":[],"version":"current","frontMatter":{},"sidebar":"forDevelopers","previous":{"title":"Options and mappings","permalink":"/sofie-core/docs/for-developers/device-integrations/options-and-mappings"},"next":{"title":"TSR Integration API","permalink":"/sofie-core/docs/for-developers/device-integrations/tsr-api"}}');var i=o(62540),a=o(43023);const s={},r="TSR Actions",c={},d=[];function l(e){const t={admonition:"admonition",code:"code",h1:"h1",header:"header",p:"p",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"tsr-actions",children:"TSR Actions"})}),"\n",(0,i.jsx)(t.p,{children:"Sometimes a state based model isn't enough and you just need to fire an action. In Sofie we try to be strict about any playout operations needing to be state based, i.e. doing a transition operation on a vision mixer should be a result of a state change, not an action. However, there are things that are easier done with actions. For example cleaning up a playlist on a graphics server or formatting a disk on a recorder. For these scenarios we have added TSR Actions."}),"\n",(0,i.jsx)(t.p,{children:"TSR Actions can be triggered through the UI by a user, through blueprints when the rundown is activated or deactivated or through adlib actions."}),"\n",(0,i.jsxs)(t.p,{children:["When implementing the TSR Actions API you should start by defining a JSON schema outlying the action id's and payload your integration will consume. Once you've done this you're ready to implement the actions as callbacks on the ",(0,i.jsx)(t.code,{children:"actions"})," property of your integration."]}),"\n",(0,i.jsx)(t.admonition,{type:"warning",children:(0,i.jsx)(t.p,{children:"Beware that if your action changes the state of the device you should handle this appropriately by resetting the resolver"})})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},43023:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>r});var n=o(63696);const i={},a=n.createContext(i);function s(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);